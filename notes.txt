A regarder :
	* Mach-O File Format
	* https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html
	* MachOView
	* #include /usr/include/mach-o/loader.h
	* #include /usr/include/mach-o/nlist.h
	* man nm

	https://elearning.intra.42.fr/notions/nm-otool/subnotions/nm-otool-nm/videos/nm-otool-e8e558d7-991e-4de5-91af-c2f3d728d857

http://math-atlas.sourceforge.net/devel/assembly/MachORuntime.pdf#page=47&zoom=100,0,300

Man nm :

Nm displays the name list (symbol table) of each object file in the argument list.  If an argument is an archive, a listing for each object file in the archive will be produced.

 Each symbol name is preceded by its value (blanks if undefined).

 exemple archive :

libft/libft.a(ft_strstr.o):
0000000000000000 T _ft_strstr

libft/libft.a(ft_strsub.o):
                 U _ft_strnew
0000000000000000 T _ft_strsub

libft/libft.a(ft_strtrim.o):
00000000000001d0 t _ft_countwsend
0000000000000140 t _ft_countwsstart
                 U _ft_strdup
                 U _ft_strlen
                 U _ft_strnew
0000000000000000 T _ft_strtrim

Each symbol name is preceded by its value (blanks if undefined).  Unless the -m option is specified, this value is followed by one of the following characters, representing the symbol type:
U (undefined),
A (absolute),
T (text section symbol),
D (data  section  symbol),
B (bss  section symbol),
C (common symbol),
S (symbol in a section other than those above),
or I (indirect symbol).
If the symbol is local (non-external), the symbol's type is instead represented by the corresponding low-ercase letter.
A lower case u in a dynamic shared library indicates a undefined reference to a private external in another module in the same library.

If the symbol is a Objective C method, the symbol name is +-[Class_name(category_name) method:name:], where `+' is for class methods, `-' is for instance methods, and (category_name) is present only when the method is in a category.

The output is sorted alphabetically by default.

Usage :

si fichier is dir
	ft_nm: dir: Is a directory.
si fichier pas object file :
	ft_nm: src/ft_nm.c The file was not recognized as a valid object file


Strategie :

Pour chaque argument (si pas argument checker a.out) :

Pour chaque argument :


2) determiner le magic number -> prendre un uint32_t et checker de quelle type il est.
		a) permet de savoir quelle type de struct il faut utiliser
		b) on check filetype pour savoir quelle type de fichier grace aux define dans loader.h

3)

nm fonctionne sur lien symbolique

besoin de determiner tous les formats de fichier lu par nm et leur magic correspondant

on peut trouver les different magic dans les .h des includes

deux types d'objects files :
	- Mach-O
		- comprend les binaires compilés
		- les fichiers objet .o
	- Universal Binaries / Fat Files (ont un header avant le mach-o header du prenier mach-o)
		-> /usr/include/mach-o/fat.h FAT_MAGIC       0xcafebabe
		-> peut avoir differente architecture
	- les archives .a
		-> voir le magic dans ar.h


load commands == une table des matières, pour savoir a quel offset sont les differents segement,
On veut savoir ou est load commands de LC_SYMTAB
les load commands commencent juste apres le header, toujours la meme taille, donc si on sait
la taille du header (en fonction du magic ?) on sait ou se deplacer pour iterer dessus
on avance ensuite de lc->cmdsize


une fois qu'on a le symbol representé par une struct nlist qui se situe à file + struct symtab_64 sym + sym->symoff

on a le nom du symbol dans la stringtable donné par file + sym+stroff
pour chaque n_list ( leur nombre est dans sym->nsyms)
	on imprime son nom qui se situe à stringtable + el[i].n_un.n_strx
	on check son type en appliquand le masque binaire N_TYPE sur le el[i].ntype
		N_UNDF	0x0		/* undefined, n_sect == NO_SECT */
			Afficher U
        N_ABS	0x2		/* absolute, n_sect == NO_SECT */
        N_SECT	0xe		/* defined in section number n_sect */

        	il faut retrouver la lc qui a le numero de section donné par el[i].n_sect
        	ca sera la lc ou lc->cmd == LC_SEGMENT (strut segment_command) ou nsects < el[i].n_sect
			il faut pointé une struct section_64 sur file + segment_command->fileoff puis d'avancer du nombre de section voulu
			on affiche le symbole en fonction du sectname (?)

        N_PBUD	0xc		/* prebound undefined (defined in a dylib) */
        N_INDR	0xa		/* indirect */


int			read_lc_segment(struct segment_command_64 *segment, char *file)
{
	int i = 0;
	struct section_64 *section;
	ft_printf("segname = %s et nsects = %d\n", segment->segname, segment->nsects);
	section = (struct section_64*)((void*)segment + sizeof(struct segment_command_64));
	while (i < segment->nsects)
	{
		ft_printf("sec num: %d sectname = %s, segname = %s\n", i + 1, section[i].sectname, section[i].segname);
		i++;
	}
	return (TRUE);
}

int			handle_64(t_manager *manager)
{
	struct mach_header_64	*header;
	struct load_command		*lc;
	int 					i;
//	;

	i = 0;
	header = (struct mach_header_64*)manager->file;
	lc = (struct load_command*)((void*)manager->file + sizeof(struct mach_header_64));
	manager->ncmds = header->ncmds;
	while (i < header->ncmds)
	{
		ft_printf("lc->cmd : %#x\n", lc->cmd);
		if (lc->cmd == LC_SEGMENT_64)
			read_lc_segment((struct segment_command_64*)lc, manager->file);
//		if (lc->cmd == LC_SYMTAB);
//			read_symtan();
		lc = (void*)lc + lc->cmdsize;
		i++;
	}
	return (TRUE);
}

	while (i < manager->symtab->nsyms)
	{
		ft_bzero(&symbol, sizeof(t_symbol));
		symbol.sym_name = stringtable + el[i].n_un.n_strx;
//		get_symbol(&symbol, el[i].n_type , el[i].n_sect, manager);
		ft_printf("value = %#.16x ,type = %#x, %s\n", el[i].n_value, el[i].n_type & N_TYPE, stringtable + el[i].n_un.n_strx);
		i++;
	}
	return (TRUE);